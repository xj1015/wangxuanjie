SpringBoot 、MyBatis 、 MySQL、RabbitMQ、Redis

1. 用户密码二次加密，传输时加密和数据库加密使用MD5
2. session使用redis实现
3. 统一异常处理
4. 对象缓存，商品对象，订单对象，项目预热写到redsi中
5. 内存标记 + Redis预减库存 + RabbitMQ异步处理

1）在用户发起秒杀访问时，先访问本地已经初始化好的map，看当前秒杀商品id的库存是否已售罄，若已售罄，直接返回秒杀结束异常；若库存还有，在执行下面的操作。通过内存标记可以减少对后面步骤中的Redis访问操作，降低Redis的压力，不然每个请求都将访问一次Redis。
2）系统启动时，即将商品和库存数据初始化到redis中（通过实现InitializingBean接口的afterPropertiesSet方法），所有的抢购操作都在Redis中进行处理，通过Redis预减少库存来减少数据库访问。SpringBoot启动后实现自动执行其它业务方法功能
3）通过使用RabbitMQ用异步队列处理下单，实现系统高响应。此处响应客户端后，一般都是抢购成功了，当然不排除例外，此时客户端通过ajax请求轮询访问下单结果接口，直到响应状态成功或者失败。

超卖：使用唯一索引，用户id和商品id添加唯一索引，避免同一个用户同时发送两个请求到两件相同商品
使用乐观锁，给商品信息表增加一个version字段，为每一条数据加上版本。每次更新的时候version+1，并且更新时候带上版本号，当提交前版本号等于更新前版本号，说明此时没有被其他线程影响到，正常更新，如果冲突了则不会进行提交更新。当库存是足够的情况下发生乐观锁冲突就进行一定次数的重试
接口限流，可以使用redis
